# -*- coding: utf-8 -*-
"""Regular_Expression_session_1_18IT033.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jUs5iH0rUKc3HxHeYmUx2D4bzmViQH6L

# Regular Experession in Python

#### What is regular Expression?

A RegEx, or Regular Expression, is a sequence of characters that forms a search pattern in a string.
RegEx can be used to check if a string contains the specified search pattern.
Regular Expression is independent of any programming language, and you can find general rules of regular expression on [this link.](https://en.wikipedia.org/wiki/Regular_expression)

> Regular expressions are used in search engines, search and replace dialogs of word processors and text editors, in text processing utilities such as sed and AWK and in lexical analysis. Many programming languages provide regex capabilities either built-in or via libraries.

Python module re - provides regular expression matching operations similar to those found in Perl.
[Here is original documentation of re module.](https://docs.python.org/3/library/re.html)
Also, gentle introduction to usage of Regular expression in python is available [Here.](https://docs.python.org/3/howto/regex.html#regex-howto)


* Refereces


https://github.com/python/cpython/blob/3.8/Lib/re.py

https://docs.python.org/3/library/re.html
"""

import re

"""re module exports the following functions:

    match     Match a regular expression pattern to the beginning of a string.
    fullmatch Match a regular expression pattern to all of a string.
    search    Search a string for the presence of a pattern.
    sub       Substitute occurrences of a pattern found in a string.
    subn      Same as sub, but also return the number of substitutions made.
    split     Split a string by the occurrences of a pattern.
    findall   Find all occurrences of a pattern in a string.
    finditer  Return an iterator yielding a Match object for each match.
    compile   Compile a pattern into a Pattern object.
    purge     Clear the regular expression cache.
    escape    Backslash all non-alphanumerics in a string.
"""

import re
''' 
re.match(pattern, string, flags=0)

If zero or more characters at the beginning of string match the regular expression pattern, 
return a corresponding match object. 
Return None if the string does not match the pattern; 

Note that even in MULTILINE mode, re.match() will only match at the 
beginning of the string and not at the beginning of each line.
'''

sample_string="I wonder if store will open if owner is not there"
sample_string2="If I am late, I am sorry"

print(re.match("If", sample_string))
print(re.match("If", sample_string2))

'''
re.fullmatch(pattern, string, flags=0)

If the whole string matches the regular expression pattern, return a corresponding match object. 
Return None if the string does not match the pattern; 

'''

print(re.fullmatch("If", sample_string))
print(re.fullmatch("If my name is", "If my name is "))
print(re.fullmatch("If my name is", "If my name is"))

'''
re.search(pattern, string, flags=0)

Scan through string looking for the first location 
where the regular expression pattern produces a match, and 
return a corresponding match object. 
Return None if no position in the string matches the pattern; 

'''
print(re.search("open", sample_string))
print(re.search("if", "If"))
print(re.search("am sorry", sample_string2))

'''
re.sub(pattern, repl, string, count=0, flags=0)
  
  Return the string obtained by replacing pattern in string by the repl. 
  If the pattern isn’t found, string is returned unchanged. 
  repl can be a string or a function; 
  if it is a string, any backslash escapes in it are processed. 
  That is, \n is converted to a single newline character. 
  Unknown escapes of ASCII letters are reserved for future use and treated as errors. 
  Other unknown escapes such as \& are left alone. 
  Backreferences, such as \6, are replaced with the substring matched by group 6 in the pattern. 
'''

print(re.sub("open","open,",sample_string))
print(re.sub(", ",",\n",sample_string2))

'''
re.subn(pattern, repl, string, count=0, flags=0)

Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made).
'''
print(re.subn("if","if,",sample_string))
print(re.subn("am sorry","apologise",sample_string2))

'''
re.split(pattern, string, maxsplit=0, flags=0)

Split string by the occurrences of pattern. 
If capturing parentheses are used in pattern, 
then the text of all groups in the pattern are also returned as part of the resulting list. 
If maxsplit is nonzero, at most maxsplit splits occur, 
and the remainder of the string is returned as the final element of the list.
'''
print(re.split("if",sample_string,1))
print(re.split("am",sample_string2))

'''
re.findall(pattern, string, flags=0)

Return all non-overlapping matches of pattern in string, as a list of strings. 
The string is scanned left-to-right, and matches are returned in the order found. 
If one or more groups are present in the pattern, return a list of groups; 
this will be a list of tuples if the pattern has more than one group. 
Empty matches are included in the result.
'''

print(re.findall("er",sample_string))
print(re.findall("er",sample_string2))
print(re.findall("am",sample_string2))

'''
re.finditer(pattern, string, flags=0)

Return an iterator yielding match objects over all non-overlapping matches 
for the RE pattern in string. 
The string is scanned left-to-right, and matches are returned in the order found. 
'''
print(re.finditer("er",sample_string))
rex = re.finditer("er",sample_string)
for i in rex:
  print(i)

print(re.finditer("er",sample_string2))
rex1 = re.finditer("er",sample_string2)
for i in rex1:
  print(i)

print(re.finditer("am",sample_string2))
rex2 = re.finditer("am",sample_string2)
for i in rex2:
  print(i)

'''
re.compile(pattern, flags=0)

Compile a regular expression pattern into a regular expression object,
 which can be used for matching using its match(), search() and other methods.

The expression’s behaviour can be modified by specifying a flags value. 
Flag Values can be any of the re flag variables, combined using bitwise OR (the | operator).

Note: Using re.compile() and saving the resulting regular expression object for 
reuse is more efficient when the expression will be used several times in a single program.
'''
string1 = "18IT033"
string2 = "My id is 18CE033"
pattern1="^[0-9]{2}(IT)[0-9]{3}"
patt1 = re.compile(pattern1)
result1 = patt1.match(string1)
print(result1)
result1 = re.match(pattern1, string1)
print(result1)
result2 = patt1.match(string2)
print(result2)

'''
re.purge()
  Clear the regular expression cache.
'''

re.purge()

'''
re.escape(pattern)
Escape special characters in pattern. 
This is useful if you want to match an arbitrary literal string 
that may have regular expression metacharacters in it.
'''
print(re.escape("h.(h)"))
print(re.escape("n&n"))
print(re.escape("n*{n}"))